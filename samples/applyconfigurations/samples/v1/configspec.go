// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	operatorv1 "github.com/openshift/api/operator/v1"
	samplesv1 "github.com/openshift/api/samples/v1"
)

// ConfigSpecApplyConfiguration represents a declarative configuration of the ConfigSpec type for use
// with apply.
//
// ConfigSpec contains the desired configuration and state for the Samples Operator, controlling
// various behavior around the imagestreams and templates it creates/updates in the
// openshift namespace.
type ConfigSpecApplyConfiguration struct {
	// managementState is top level on/off type of switch for all operators.
	// When "Managed", this operator processes config and manipulates the samples accordingly.
	// When "Unmanaged", this operator ignores any updates to the resources it watches.
	// When "Removed", it reacts that same wasy as it does if the Config object
	// is deleted, meaning any ImageStreams or Templates it manages (i.e. it honors the skipped
	// lists) and the registry secret are deleted, along with the ConfigMap in the operator's
	// namespace that represents the last config used to manipulate the samples,
	ManagementState *operatorv1.ManagementState `json:"managementState,omitempty"`
	// samplesRegistry allows for the specification of which registry is accessed
	// by the ImageStreams for their image content.  Defaults on the content in https://github.com/openshift/library
	// that are pulled into this github repository, but based on our pulling only ocp content it typically
	// defaults to registry.redhat.io.
	SamplesRegistry *string `json:"samplesRegistry,omitempty"`
	// architectures determine which hardware architecture(s) to install, where x86_64, ppc64le, and s390x are the only
	// supported choices currently.
	Architectures []string `json:"architectures,omitempty"`
	// skippedImagestreams specifies names of image streams that should NOT be
	// created/updated.  Admins can use this to allow them to delete content
	// they don’t want.  They will still have to manually delete the
	// content but the operator will not recreate(or update) anything
	// listed here.
	SkippedImagestreams []string `json:"skippedImagestreams,omitempty"`
	// skippedTemplates specifies names of templates that should NOT be
	// created/updated.  Admins can use this to allow them to delete content
	// they don’t want.  They will still have to manually delete the
	// content but the operator will not recreate(or update) anything
	// listed here.
	SkippedTemplates []string `json:"skippedTemplates,omitempty"`
	// skippedHelmCharts specifies names of helm charts that should NOT be
	// managed. Admins can use this to allow them to delete content
	// they don’t want. They will still have to MANUALLY DELETE the
	// content but the operator will not recreate(or update) anything
	// listed here. Few examples of the name of helmcharts which can be skipped are
	// 'redhat-redhat-perl-imagestreams','redhat-redhat-nodejs-imagestreams','redhat-nginx-imagestreams',
	// 'redhat-redhat-ruby-imagestreams','redhat-redhat-python-imagestreams','redhat-redhat-php-imagestreams',
	// 'redhat-httpd-imagestreams','redhat-redhat-dotnet-imagestreams'. Rest of the names can be obtained from
	// openshift console --> helmcharts -->installed helmcharts. This will display the list of all the
	// 12 helmcharts(of imagestreams)being installed by Samples Operator. The skippedHelmCharts must be a
	// valid Kubernetes resource name. May contain only lowercase alphanumeric characters, hyphens and periods,
	// and each period separated segment must begin and end with an alphanumeric character. It must be non-empty
	// and at most 253 characters in length
	SkippedHelmCharts []samplesv1.HelmChartName `json:"skippedHelmCharts,omitempty"`
}

// ConfigSpecApplyConfiguration constructs a declarative configuration of the ConfigSpec type for use with
// apply.
func ConfigSpec() *ConfigSpecApplyConfiguration {
	return &ConfigSpecApplyConfiguration{}
}

// WithManagementState sets the ManagementState field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ManagementState field is set to the value of the last call.
func (b *ConfigSpecApplyConfiguration) WithManagementState(value operatorv1.ManagementState) *ConfigSpecApplyConfiguration {
	b.ManagementState = &value
	return b
}

// WithSamplesRegistry sets the SamplesRegistry field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the SamplesRegistry field is set to the value of the last call.
func (b *ConfigSpecApplyConfiguration) WithSamplesRegistry(value string) *ConfigSpecApplyConfiguration {
	b.SamplesRegistry = &value
	return b
}

// WithArchitectures adds the given value to the Architectures field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Architectures field.
func (b *ConfigSpecApplyConfiguration) WithArchitectures(values ...string) *ConfigSpecApplyConfiguration {
	for i := range values {
		b.Architectures = append(b.Architectures, values[i])
	}
	return b
}

// WithSkippedImagestreams adds the given value to the SkippedImagestreams field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the SkippedImagestreams field.
func (b *ConfigSpecApplyConfiguration) WithSkippedImagestreams(values ...string) *ConfigSpecApplyConfiguration {
	for i := range values {
		b.SkippedImagestreams = append(b.SkippedImagestreams, values[i])
	}
	return b
}

// WithSkippedTemplates adds the given value to the SkippedTemplates field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the SkippedTemplates field.
func (b *ConfigSpecApplyConfiguration) WithSkippedTemplates(values ...string) *ConfigSpecApplyConfiguration {
	for i := range values {
		b.SkippedTemplates = append(b.SkippedTemplates, values[i])
	}
	return b
}

// WithSkippedHelmCharts adds the given value to the SkippedHelmCharts field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the SkippedHelmCharts field.
func (b *ConfigSpecApplyConfiguration) WithSkippedHelmCharts(values ...samplesv1.HelmChartName) *ConfigSpecApplyConfiguration {
	for i := range values {
		b.SkippedHelmCharts = append(b.SkippedHelmCharts, values[i])
	}
	return b
}
