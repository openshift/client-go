// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	monitoringv1 "github.com/openshift/api/monitoring/v1"
	intstr "k8s.io/apimachinery/pkg/util/intstr"
)

// RuleApplyConfiguration represents a declarative configuration of the Rule type for use
// with apply.
//
// Rule describes an alerting rule.
// See Prometheus documentation:
// - https://www.prometheus.io/docs/prometheus/latest/configuration/alerting_rules
type RuleApplyConfiguration struct {
	// alert is the name of the alert. Must be a valid label value, i.e. may
	// contain any Unicode character.
	Alert *string `json:"alert,omitempty"`
	// expr is the PromQL expression to evaluate. Every evaluation cycle this is
	// evaluated at the current time, and all resultant time series become pending
	// or firing alerts.  This is most often a string representing a PromQL
	// expression, e.g.: mapi_current_pending_csr > mapi_max_pending_csr
	// In rare cases this could be a simple integer, e.g. a simple "1" if the
	// intent is to create an alert that is always firing.  This is sometimes used
	// to create an always-firing "Watchdog" alert in order to ensure the alerting
	// pipeline is functional.
	Expr *intstr.IntOrString `json:"expr,omitempty"`
	// for is the time period after which alerts are considered firing after first
	// returning results.  Alerts which have not yet fired for long enough are
	// considered pending.
	For *monitoringv1.Duration `json:"for,omitempty"`
	// labels to add or overwrite for each alert.  The results of the PromQL
	// expression for the alert will result in an existing set of labels for the
	// alert, after evaluating the expression, for any label specified here with
	// the same name as a label in that set, the label here wins and overwrites
	// the previous value.  These should typically be short identifying values
	// that may be useful to query against.  A common example is the alert
	// severity, where one sets `severity: warning` under the `labels` key:
	Labels map[string]string `json:"labels,omitempty"`
	// annotations to add to each alert.  These are values that can be used to
	// store longer additional information that you won't query on, such as alert
	// descriptions or runbook links.
	Annotations map[string]string `json:"annotations,omitempty"`
}

// RuleApplyConfiguration constructs a declarative configuration of the Rule type for use with
// apply.
func Rule() *RuleApplyConfiguration {
	return &RuleApplyConfiguration{}
}

// WithAlert sets the Alert field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Alert field is set to the value of the last call.
func (b *RuleApplyConfiguration) WithAlert(value string) *RuleApplyConfiguration {
	b.Alert = &value
	return b
}

// WithExpr sets the Expr field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Expr field is set to the value of the last call.
func (b *RuleApplyConfiguration) WithExpr(value intstr.IntOrString) *RuleApplyConfiguration {
	b.Expr = &value
	return b
}

// WithFor sets the For field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the For field is set to the value of the last call.
func (b *RuleApplyConfiguration) WithFor(value monitoringv1.Duration) *RuleApplyConfiguration {
	b.For = &value
	return b
}

// WithLabels puts the entries into the Labels field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Labels field,
// overwriting an existing map entries in Labels field with the same key.
func (b *RuleApplyConfiguration) WithLabels(entries map[string]string) *RuleApplyConfiguration {
	if b.Labels == nil && len(entries) > 0 {
		b.Labels = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.Labels[k] = v
	}
	return b
}

// WithAnnotations puts the entries into the Annotations field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Annotations field,
// overwriting an existing map entries in Annotations field with the same key.
func (b *RuleApplyConfiguration) WithAnnotations(entries map[string]string) *RuleApplyConfiguration {
	if b.Annotations == nil && len(entries) > 0 {
		b.Annotations = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.Annotations[k] = v
	}
	return b
}
